# Robot Management App – API / DDD コーディング規約

## 1. 基本方針

- **DDD + レイヤードアーキテクチャ**
- **Domain を中心に設計**
- ビジネスロジックは **必ず Domain に置く**
- クラスベース実装を基本とする

```
Presentation → Application → Domain
Infrastructure →（依存性逆転で注入）
```

---

## 2. レイヤー別ルール

### Domain 層（最重要）

**責務**

- ビジネスルール
- エンティティ / 値オブジェクト
- リポジトリインターフェース

**ルール**

- エンティティは **必ず class**
- `constructor` でバリデーション
- 状態変更は **メソッド経由のみ**
- `readonly` を基本とする
- `isXxx()`, `canXxx()` を提供
- ID は必須・`readonly`
- Domain は他レイヤーに依存しない

```ts
class Robot {
  constructor(
    public readonly id: number,
    public readonly name: string,
    private _status: "idle" | "moving"
  ) {}
}
```

**Repository（Domain）**

- `I{Entity}Repository`
- Domain エンティティのみ扱う
- 永続化技術を意識しない

```ts
interface IRobotRepository {
  findById(id: number): Promise<Robot | null>;
  create(robot: Robot): Promise<Robot>;
  update(robot: Robot): Promise<Robot>;
}
```

---

### Application 層

**責務**

- ユースケース実装
- Domain のオーケストレーション
- トランザクション境界
- DTO ↔ Domain 変換

**ルール**

- **クラスベース Service**
- クラス名: `{Verb}{Entity}Service`
- メソッド名: `invoke()`
- Domain メソッドを呼び出すだけ
- ビジネスルールは書かない
- Repository は DI で受け取る

```ts
class MoveRobotService {
  constructor(private repo: IRobotRepository) {}

  async invoke(id: number, targetNodeId: number) {
    const robot = await this.repo.findById(id);
    if (!robot) throw new Error("NotFound");

    robot.startMoving(targetNodeId);
    await this.repo.update(robot);
  }
}
```

---

### Infrastructure 層

**責務**

- DB / 外部 API
- Repository 実装

**ルール**

- Domain の Repository を実装
- `create/update` は **Entity を受け取る**
- DB row → Entity 変換は `toDomain()`
- 技術詳細を他層に漏らさない

```ts
class RobotRepository implements IRobotRepository {
  async findById(id: number): Promise<Robot | null> { ... }
}
```

---

### Presentation 層

**責務**

- HTTP I/O
- 入力バリデーション
- レスポンス整形

**ルール**

- Controller / Router にビジネスロジック禁止
- Service を呼ぶだけ
- エラーは middleware に委譲
- HTTP ステータスを正しく使う

```ts
router.post("/", async (req, res, next) => {
  try {
    const result = await createRobotService.invoke(req.body);
    res.status(201).json(result);
  } catch (e) {
    next(e);
  }
});
```

---

## 3. エラー設計

| 層           | 役割                             |
| ------------ | -------------------------------- |
| Domain       | ビジネスルール違反を例外で投げる |
| Application  | Domain エラーを用途別に変換      |
| Presentation | HTTP エラーに変換                |

---

## 4. 命名規約（要点）

- Entity: `PascalCase`
- Repository IF: `I{Entity}Repository`
- Service: `{Verb}{Entity}Service`
- Method: `invoke()`
- Directory: `camelCase`

---

## 5. 禁止事項（重要）

- ❌ Domain で DTO を使う
- ❌ Controller にビジネスロジックを書く
- ❌ Repository がプリミティブを返す
- ❌ Service が直接 SQL を書く
- ❌ 状態を直接書き換える

---

## 6. 実装チェックリスト

- [ ] Domain は class ベース
- [ ] バリデーションは constructor
- [ ] ルールは Domain メソッド
- [ ] Repository IF は Domain
- [ ] Service は invoke()
- [ ] Controller は薄い
- [ ] DI を使用
- [ ] テストあり

---
