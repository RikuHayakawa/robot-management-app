# Robot Management App – API / DDD コーディング規約（改訂版）

## 1. 基本方針（明確化）

- **DDD + レイヤードアーキテクチャ**
- **Domain を中心に設計**
- ビジネスロジックは **必ず Domain に置く**
- Application は **ユースケースのみ**
- Presentation は **I/O 変換のみ**
- REST / GraphQL は **Application を共有**
- クラスベース実装を基本とする

```
Presentation → Application → Domain
Infrastructure →（DI により注入）
```

---

## 2. レイヤー別ルール

### Domain 層（最重要）

**責務**

- ビジネスルール
- エンティティ / 値オブジェクト
- リポジトリインターフェース

**ルール**

- エンティティは **必ず class**
- `constructor` でバリデーション
- 状態変更は **メソッド経由のみ**
- `readonly` を基本とする
- `isXxx()`, `canXxx()` を提供
- ID は必須・`readonly`
- Domain は他レイヤーに依存しない

```ts
class Robot {
  constructor(
    public readonly id: number,
    public readonly name: string,
    private _status: "idle" | "moving"
  ) {}
}
```

**Repository（Domain）**

- `I{Entity}Repository`
- Domain エンティティのみ扱う
- 永続化技術を意識しない

```ts
interface IRobotRepository {
  findById(id: number): Promise<Robot | null>;
  create(robot: Robot): Promise<Robot>;
  update(robot: Robot): Promise<Robot>;
}
```

---

### Application 層（DTO を明文化）

**責務**

- ユースケースの実行
- Domain オブジェクトの組み合わせ
- トランザクション境界
- **UseCase DTO の定義と使用**

**ルール（重要変更）**

#### ■ ユースケース DTO を必ず定義する

Application 層では **以下 2 種類の DTO を必須とする**

| 種類       | 役割             |
| ---------- | ---------------- |
| Input DTO  | ユースケース入力 |
| Result DTO | ユースケース出力 |

- DTO は **Application 層に置く**
- Domain Entity を外に返さない
- DTO は **pure data（getter / ロジック禁止）**

**命名規約（Application DTO）**

| 種類   | 命名                 |
| ------ | -------------------- |
| Input  | `{UseCase}InputDto`  |
| Result | `{UseCase}ResultDto` |

**Service（UseCase）**

- **クラスベース Service**
- クラス名: `{Verb}{Entity}Service`
- メソッド名: `invoke()`
- Domain メソッドを呼び出すだけ
- ビジネスルールは書かない
- Repository は DI で受け取る

**例：CreateRobot**

```ts
// application/robot/dto/CreateRobotInputDto.ts
export class CreateRobotInputDto {
  constructor(
    public readonly name: string,
    public readonly status: "idle" | "moving",
    public readonly currentNodeId: number | null
  ) {}
}
```

```ts
// application/robot/dto/CreateRobotResultDto.ts
export class CreateRobotResultDto {
  constructor(
    public readonly id: number,
    public readonly name: string,
    public readonly status: "idle" | "moving",
    public readonly currentNodeId: number | null
  ) {}
}
```

```ts
// application/robot/robotCommands.ts
class CreateRobotService {
  constructor(private repo: IRobotRepository) {}

  async invoke(input: CreateRobotInputDto): Promise<CreateRobotResultDto> {
    const robot = new Robot(0, input.name, input.status, input.currentNodeId);
    const saved = await this.repo.create(robot);

    return new CreateRobotResultDto(
      saved.id,
      saved.name,
      saved.status,
      saved.currentNodeId
    );
  }
}
```

**禁止事項（Application）**

- ❌ HTTP / GraphQL の型を使う
- ❌ req / res を触る
- ❌ Domain Entity をそのまま返す
- ❌ Presentation 都合のフィールドを持つ

---

### Infrastructure 層

**責務**

- DB / 外部 API
- Repository 実装

**ルール**

- Domain の Repository を実装
- `create/update` は **Entity を受け取る**
- DB row → Entity 変換は `toDomain()`
- 技術詳細を他層に漏らさない

```ts
class RobotRepository implements IRobotRepository {
  async findById(id: number): Promise<Robot | null> { ... }
}
```

---

### Presentation 層（全面改訂）

**基本方針**

- Presentation 層は **翻訳層**
- REST / GraphQL は **完全分離**
- Application DTO を **境界として使用**

**Presentation 共通ルール**

- Domain Entity を扱わない
- Application Service だけを呼ぶ
- DTO ↔ 表示形式の変換のみ行う
- ロジック・判断は禁止

**Presentation ディレクトリ構成（必須）**

```
presentation/
├─ http/        # REST API
├─ graphql/     # GraphQL API
└─ common/      # 共通変換・Presenter（必要に応じて）
```

**REST API 規約（presentation/http）**

> ※ 詳細は `cursor/rules/rest.md` を参照

**構成**

```
presentation/http/
├─ routers/
├─ controllers/
├─ requests/
├─ responses/
└─ middlewares/
```

**REST ルール**

- Controller は **Application Service を 1 回呼ぶだけ**
- Input DTO を生成して渡す
- Result DTO を Response に変換
- try-catch は可、判断ロジックは禁止

```ts
const input = new CreateRobotInputDto(
  req.body.name,
  req.body.status,
  req.body.currentNodeId ?? null
);

const result = await service.invoke(input);
res.status(201).json(RobotResponse.from(result));
```

**GraphQL API 規約（presentation/graphql）**

> ※ 詳細は `cursor/rules/graphql.md` を参照

**構成**

```
presentation/graphql/
├─ schema/
├─ resolvers/
├─ inputs/
└─ types/
```

**GraphQL ルール**

- Resolver = Controller と同義
- args → Input DTO に変換
- Result DTO → GraphQL Type に変換
- field resolver にロジック禁止

```ts
const input = new CreateRobotInputDto(
  args.input.name,
  args.input.status,
  args.input.currentNodeId ?? null
);

return RobotType.from(await service.invoke(input));
```

---

## 3. エラー設計（明確化）

| 層           | 例外                  |
| ------------ | --------------------- |
| Domain       | BusinessRuleViolation |
| Application  | UseCaseError          |
| Presentation | HTTP / GraphQL Error  |

- Presentation で **例外変換のみ**
- Domain 例外を直接外に出さない

---

## 4. 命名規約（要点）

- Entity: `PascalCase`
- Repository IF: `I{Entity}Repository`
- Service: `{Verb}{Entity}Service`
- Input DTO: `{UseCase}InputDto`
- Result DTO: `{UseCase}ResultDto`
- Method: `invoke()`
- Directory: `camelCase`

---

## 5. 禁止事項（重要・追加）

### Domain

- ❌ Domain で DTO を使う
- ❌ 状態を直接書き換える

### Application

- ❌ HTTP / GraphQL の型を使う
- ❌ req / res を触る
- ❌ Domain Entity をそのまま返す
- ❌ Presentation 都合のフィールドを持つ
- ❌ Application DTO を省略

### Infrastructure

- ❌ Repository がプリミティブを返す
- ❌ Service が直接 SQL を書く

### Presentation

- ❌ Presentation が Domain を import
- ❌ REST と GraphQL で Service を分ける
- ❌ Controller にビジネスロジックを書く
- ❌ Result DTO を使わずそのまま返す

---

## 6. 実装チェックリスト

- [ ] Domain は class ベース
- [ ] バリデーションは constructor
- [ ] ルールは Domain メソッド
- [ ] Repository IF は Domain
- [ ] Service は invoke()
- [ ] Input DTO / Result DTO を定義
- [ ] Domain Entity を直接返さない
- [ ] Controller は薄い（Service を 1 回呼ぶだけ）
- [ ] Presentation は Domain を import しない
- [ ] DI を使用
- [ ] テストあり

---

## 7. 最終要約

> **Application は必ず DTO 境界を持つ。
> Presentation は翻訳のみ。
> REST / GraphQL は Application を共有し、実装は完全分離。**
